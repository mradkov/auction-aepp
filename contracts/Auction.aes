contract Auction =

  record state = {  owner         : address,
                    startBlock    : int,
                    endBlock      : int,
                    canceled      : bool,
                    highestBidder : address,
                    fundsByBidder : map(address, int) }

  datatype event = LogBid(indexed address, indexed int)
    | LogWithdrawal(indexed address, indexed int)
    | LogCanceled(string)

  /*
  * @dev - Function for withdrawing the funds
  * @param _startBlock : int - the number of the auction starting block
  * @param _endBlock : int - the number of the auction ending block
  */
  public stateful function init(_startBlock: int, _endBlock: int) : state =
    require(_startBlock =< _endBlock, "Start block should be smaller than the ending block.")
    require(_startBlock > Chain.block_height, "The starting block should be greater than the current chain block.")
    { owner         = Call.caller,
      startBlock    = _startBlock,
      endBlock      = _endBlock,
      canceled      = false,
      highestBidder = #0,
      fundsByBidder = {} }

  /*
  * @dev - Function to place bid in the auction
  */
  public stateful function placeBid() =
    onlyAfterStart()
    onlyBeforeEnd()
    onlyNotCanceled()
    onlyNotOwner()
    
    // reject transactions without value
    require(Call.value > 0, "Please provide more than 0 AEs.")

    // calculate the user's total bid based on the current amount they've sent to the contract
    // plus whatever has been sent with this transaction
    let newBid = state.fundsByBidder[Call.caller] + Call.value
    
    // get the current highest bid
    let lastHighestBid = state.fundsByBidder[state.highestBidder]
        
    // if the user isn't even willing to overbid the highest bid, there's nothing for us
    // to do except revert the transaction.
    require (newBid > lastHighestBid, "The provided amount is not enough for overbid.")
    
    // update the user bid
    put(state{ fundsByBidder[Call.caller] = newBid, highestBidder = Call.caller })
    Chain.event(LogBid(Call.caller, newBid))

  /*
  * @dev - Function for withdrawing the funds
  */
  public stateful function withdraw() =
    onlyEndedOrCanceled()
    let withdrawalAmount : int = 
      switch(state.canceled)
        true =>
            // the auction is cancelled and everyone can withdraw the bidding value they put in
            state.fundsByBidder[Call.caller]
        false =>
            // the auction is not cancelled and its finished normally
            // the highest bidder cannot withdraw his bids
            require(Call.caller != state.highestBidder, "The caller should not be the highest bidder.")
            // we check if the caller is the auction owner
            if (Call.caller == state.owner)
              // if its the onwer we give him the value of the winning/highest bid
              state.fundsByBidder[state.highestBidder]
            else
              // if its somebody else /other participant/ - he can withdraw his bids
              state.fundsByBidder[Call.caller]
    
    // we process the payment
    withdraw'(Call.caller, withdrawalAmount)

  /*
  * @dev - Function for changing the auction state to cancelled
  */
  public stateful function cancelAuction() =
    onlyOwner()
    onlyBeforeEnd()
    onlyNotCanceled()
    put(state { canceled = true })
    Chain.event(LogCanceled("Auction cancelled."))

  /*
  * @dev - Internal helper function for withdrawing the funds
  * @param beneficiary : address - the address to whom to send the funds
  * @param amount : int - the amount to send
  */
  private stateful function withdraw'(beneficiary : address, amount : int) =
    require (amount > 0, "Cannot withdraw 0.")
    put(state{ fundsByBidder[beneficiary] = state.fundsByBidder[beneficiary] - amount })
    Chain.spend(beneficiary, amount)
    Chain.event(LogWithdrawal(beneficiary, amount))

  /*
  * @dev - Internal helper function for reverting execution if condtion not met
  * @param b : bool - the condition
  * @param err : string - the error message to be provided
  */
  private function require(b : bool, err : string) =
    if(!b)
      abort(err)

  /*
  * @dev - Internal helper function used as modifier for checking if the auction is still active
  */
  private function onlyRunning() =
    onlyNotCanceled()
    require((Chain.block_height > state.startBlock) && (Chain.block_height < state.endBlock), "Blocks heights are not correct!")    

  /*
  * @dev - Internal helper function used as modifier for checking if the caller is the owner
  */
  private function onlyOwner() =
    require(Call.caller == state.owner, "Only the owner is allowed!")

  /*
  * @dev - Internal helper function used as modifier for checking if the caller is NOT the owner
  */
  private function onlyNotOwner() =
    require(Call.caller != state.owner, "Owner is not allowed!")

  /*
  * @dev - Internal helper function used as modifier for checking if the call is made after the auction start
  */
  private function onlyAfterStart() =
    require(Chain.block_height > state.startBlock, "The auction is not started!")

  /*
  * @dev - Internal helper function used as modifier for checking if the call is made before the auction end
  */
  private function onlyBeforeEnd() =
    require(Chain.block_height < state.endBlock, "Already ended.")

  /*
  * @dev - Internal helper function used as modifier for checking if the call is made while the auction is not cancelled
  */
  private function onlyNotCanceled() =
    require(state.canceled == false, "Auction is cancelled.")

  /*
  * @dev - Internal helper function used as modifier for checking if the call is made after the auction is ended or cancelled
  */
  private function onlyEndedOrCanceled() =
    require((Chain.block_height > state.endBlock) || (state.canceled == true), "The auction is not ended or cancelled.")